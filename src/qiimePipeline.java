//This program has been tested with Ubuntu 16.04 using bash as the shell interpreter and FLASH version 1.2.9//Last Edited 8-2-16 by ABCimport java.io.BufferedReader;import java.io.File;import java.io.FileReader;import java.io.IOException;import java.net.URISyntaxException;import java.security.CodeSource;import java.util.HashMap;import javax.swing.JFileChooser;public class qiimePipeline {	private String sourceFolderFilename;	private File[] listOfFiles;	private File[] FLASHfiles;	private HashMap<String, R1> myReadDictTrimGalore = new HashMap<String, R1>();	private HashMap<String, R1> myReadDictFlash = new HashMap<String, R1>();	private File sourceFolder;	private String FLASHlocation; 		//Change these variables to affect the parameters of Trim Galore	private String unpaired_read1 = "100"; //Read 1 length cutoff for Trim Galore	private String unpaired_read2 = "100";//Read 2 length Cutoff for Trim Galore	private String trim_quality = "30"; //quality score cutoff for Trim Galore		//Change these variables to affect the parameter input of FLASH	private String average_read_length = "150";	private String average_fragment_length = "180";	private String fragment_stdv = "18";			/**	 * qiimePipeline	 * takes as input a filename and acts as constructor to create a new qiimePipeline object. 	 * The  filename is the name of the working directory where fastq files with the extension R1.fastq and R2.fastq	 * can be found. This pipeline relies on various commands to be effective.	 * @param filename the path on the local filesystem of the file containing the fastq files.	 */	public qiimePipeline(String filename){		sourceFolderFilename = filename;		sourceFolder = new File(sourceFolderFilename); //assigns the source folder for fastq files to this instance as a file		listOfFiles = sourceFolder.listFiles(); //creates a list of files as an Array that can be used for the TrimGalore input	}		/**	 * Place a title in and this command opens a file chooser window which has the title given to the command.	 * This command returns a directory File that can be used for further operations.	 * Source is directly taken from http://www.java2s.com/Code/Java/Swing-JFC/SelectadirectorywithaJFileChooser.htm	 * @param title The desired title of the chooser window	 * @return File The file chosen. This will be a directory	 */	public static File chooseFile(String title){  		JFileChooser chooser = new JFileChooser();	    chooser.setCurrentDirectory(new java.io.File("."));	    chooser.setDialogTitle(title);	    chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY); //only show directories	    chooser.setAcceptAllFileFilterUsed(false);		    if (chooser.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {	      System.out.println("getCurrentDirectory(): " + chooser.getCurrentDirectory());	      return chooser.getSelectedFile(); //return the selected file	    } else {	      System.out.println("No Selection ");	    }		return null;	}		/**	 * This is a helper method that takes as input a location and sets the local flash directory to that location. This isn't necessary but it avoids confusion	 * when dealing with Flash directories selected using the chooseFile above.	 * @param location the location of FLASH on the local system	 */	public void setFLASHlocation(String location){		FLASHlocation = location;	}		/**	 * Takes as input the directory of the output of the output of trimgalore and sets the location of flash input files there. 	 * This is a helper program to reduce the number of inputs required to run the index and match operations for FLASH.	 * @param trimGaloreOutput the File that trimgalore output files are stored in	 */	public void setFLASHfiles(File trimGaloreOutput){		FLASHfiles = trimGaloreOutput.listFiles();	}		/**	 * This indexes the R1 reads for preparation with TrimGalore. This step requires file extension to be R1.fastq	 * This step relies on previously creating listOfFiles with the qiimePipeline constructor	 * This creates and works with a HashMap containing all sample names.	 */	private void indexR1TrimGalore(){		for (File reads: listOfFiles){ //for every file in the initial working directory			String readName = reads.getName(); //get the name of the file			if (readName.contains("R")){				if ((readName != null) && (readName.substring(readName.lastIndexOf("R")-1, readName.length()).contains("R1"))){ // if the extension is R1.fastq					if (!myReadDictTrimGalore.containsKey(readName)){ //and it isn't already in the dictionary						R1 myR1 = new R1(readName); //create an R1 object by that name						myReadDictTrimGalore.put(readName, myR1);//and add the R1 object to the HashMap				}			}		}		}	}	/**	 * This matches the R2 reads with the R1 reads by nesting the R2 read name as an instance variable of R1.	 * The matching function works in basically the same 	 */	private void matchR2TrimGalore() {		for (File reads: listOfFiles){			String readName = reads.getName();			int start = 0;			int endOfFileName = readName.lastIndexOf("R");			int endOfExtensionName = readName.lastIndexOf(".");			String extension;			if ((endOfExtensionName - endOfFileName) > 2){				extension = readName.substring(endOfFileName + 2 , endOfExtensionName);			}			else				extension = "";			if ((readName != null) && (readName.contains("R2"))){					String R1Name = readName.substring(start, readName.lastIndexOf("R"))+  "R1" + extension + ".fastq"; //the beginning part of the name needs to match an R1 in the Hashmap, which are stored as sampleNameR1.fastq				if (myReadDictTrimGalore.containsKey(R1Name)){ // if the R1 is in the dictionary					R2 read2 = new R2(readName); //make the new R1 object					((R1) myReadDictTrimGalore.get(R1Name)).setR2(read2); // search the read HashMap for the R1 name and set an instance variable for the specified R2				}			}		}	}	/**	 * This function works the same way as the indexR1TrimGalore function only requiring FlashFiles to be created by setFlashFiles and using the myReadDictFlash HashMap	 */	private void indexR1FLASH(){		for (File reads: FLASHfiles){			String readName = reads.getName();			int startIndex = (readName.length()-8);			int endIndex = (readName.length());			String sampleName = readName.substring(startIndex,endIndex);			if ((readName != null) && (sampleName.equals("val_1.fq"))){				if (!myReadDictFlash.containsKey(readName)){					R1 myR1 = new R1(readName);					myReadDictFlash.put(readName, myR1);				}			}		}	}	/**	 * This function works the same as matchR2TrimGalore but changes the files to search and the length of the extension	 */	private void matchR2FLASH() {		for (File reads: FLASHfiles){			String readName = reads.getName();			int startIndex = (readName.length()- 8);			int endIndex = readName.length();			String suffix = readName.substring(startIndex, endIndex);			if ((readName != null) && (suffix.equals("val_2.fq"))){				int start = 0;				int endPrefix = (readName.lastIndexOf("R"));					String R1Name = readName.substring(start,endPrefix) + "R1" + readName.substring(readName.lastIndexOf("R") + 2, readName.lastIndexOf("v"))+ "val_1.fq";				if (myReadDictFlash.containsKey(R1Name)){					R2 read2 = new R2(readName);					((R1) myReadDictFlash.get(R1Name)).setR2(read2);				}			}		}	}	/**	 * This function takes a string to be used as a directory name and creates a directory with that name within the root directory of the working folder	 * @param directoryName the desired name of an output directory to be created in the root folder of the qiimePipeline source	 */	public void createWorkingFolder(String directoryName){		String parentFolder = sourceFolder.getParentFile().getAbsolutePath();		new File(parentFolder + "/" + directoryName).mkdir();	}	/**	 * trim requires several different files to help before running. It is necessary to create a full ReadDict for TrimGalore using IndexR1TrimGalore and Match R2TrimGalore	 * before running this function. this then takes every file in those dictionaries and runs trim galore from a perlscript in the resources folder of the working directory	 * To properly function this function requires that CutAdapt is properly installed and is executable in the console. If there are problems installing CutAdapt, add Cut Adapt to the $PATH.	 * If it is not possible to add CutAdapt to $PATH edit the TrimGalore file in the resources subdirectory and recompile	 *  	 * Although exceptions are thrown here they are not managed in any way.  Fix?	 * @throws IOException	 * @throws InterruptedException	 * @throws URISyntaxException	 */	public void trim() throws IOException, InterruptedException, URISyntaxException{		CodeSource codeSource = qiimePipeline.class.getProtectionDomain().getCodeSource(); // modified slightly from http://stackoverflow.com/questions/320542/how-to-get-the-path-of-a-running-jar-file		File jarFile = new File(codeSource.getLocation().toURI().getPath());		String jarDir = jarFile.getParentFile().getPath(); //these lines get the path to the root folder of the java project to allow accessing internal folders.		for (String read1: myReadDictTrimGalore.keySet()){			R1 currentRead1 = myReadDictTrimGalore.get(read1);			R2 currentRead2 = currentRead1.getR2();			    ProcessBuilder trim = new ProcessBuilder().inheritIO().command("perl",  jarDir + 			    		"/resources/trim_galore" ,  sourceFolderFilename + "/"+ currentRead1.getFileName() , sourceFolderFilename + "/" +			    				currentRead2.getFileName() ,  "--paired" ,  "--retain_unpaired", "-r1", unpaired_read1 , "-r2", unpaired_read2 , "-q", trim_quality ,  "-o", //runs trim on initial input.			    				sourceFolder.getParentFile().getPath() + "/trimOut" );			    Process trimProcess = trim.start();			    trimProcess.waitFor();		}		File trimOut = new File (sourceFolder.getParentFile().getPath() + "/trimOut");		this.setFLASHfiles(trimOut);			}		/**	 * FLASH takes as input the outputs of both index and match FLASH functions and uses these to process all of the files in the trimOut location through	 * FLASH connecting it to the perl script installed on the local machine. It is necessary to install FLASH prior to running this.	 * @throws InterruptedException	 * @throws IOException	 */	public void FLASH() throws InterruptedException, IOException{		for (String read1: myReadDictFlash.keySet()){ //for every entry in the HashMap			R1 currentRead1 = myReadDictFlash.get(read1); //get the entry's value			R2 currentRead2 = currentRead1.getR2(); //get the pairing R2			String trimLocation = sourceFolder.getParentFile().getAbsolutePath() + "/trimOut";			String FLASHoutputLocation = sourceFolder.getParentFile().getAbsolutePath() + "/FLASHout";			String outputName;			if (currentRead1.getFileName().lastIndexOf("v")-1 - (currentRead1.getFileName().lastIndexOf("R")+2) > 0){			 outputName= currentRead1.getFileName().substring(0, currentRead1.getFileName().lastIndexOf("R")) + currentRead1.getFileName().substring(currentRead1.getFileName().lastIndexOf("R")+3, currentRead1.getFileName().lastIndexOf("v")-1);			}			else outputName = currentRead1.getFileName().substring(0, currentRead1.getFileName().lastIndexOf("R")-1);			ProcessBuilder FLASH = new ProcessBuilder().inheritIO().command(FLASHlocation + "/flash",  trimLocation + "/" +  //run FLASH on the trim output files					currentRead1.getFileName(), trimLocation + "/"+ currentRead2.getFileName(), 					"-r", average_read_length, "-f", average_fragment_length, "-s", fragment_stdv, "-d", FLASHoutputLocation, "-o", outputName);			Process FLASHprocess = FLASH.start();			FLASHprocess.waitFor();		}	}	/**	 * Takes the output of FLASH and converts all files to fasta format from fastq. files coming out of Flash must be labeled with the extension _.extendedFrags.fastq	 * This is done with bash operating a concatenator that pipes its output to a line of perl script. 	 * @param FlashOutput The location of the output from FLASH	 * @throws InterruptedException	 * @throws IOException	 */	public void fastqToFasta(String FlashOutput) throws InterruptedException, IOException{		File extendedFragsLocation = new File(sourceFolder.getParentFile().getAbsolutePath() + "/" + FlashOutput);		for (File possibleExtendedFrags: extendedFragsLocation.listFiles()){			String fileName = possibleExtendedFrags.getName();			if (fileName.length()>22){ //reduces possibility of getting index out of range error, especially considering this extension is long								int startIndex = (fileName.length()-20);				int endIndex = (fileName.length()); //same protocol for obtaining suffixes as in trimGalore and FLASH--just used to check filetype				String extensionName = fileName.substring(startIndex,endIndex);				if ((fileName != null) && (fileName.length() > 22) && (extensionName.equals(".extendedFrags.fastq"))){										ProcessBuilder fastqToFasta = new ProcessBuilder().inheritIO().command(new String[]{"bash",  "-c", "cd " + sourceFolder.getParent() + 							"/convertToFasta;"							+ " cat " + extendedFragsLocation + "/" + fileName + " | " + "perl " + "-e "+  							"'$i=0;while(<>){if(/^\\@/&&$i==0){s/^\\@/\\>/;print;}elsif($i==1){print;$i=-3}$i++;}' >" + fileName.substring(0, fileName.lastIndexOf(".e")) + ".fasta"}); //bash is used here to facilitate piping										Process conversion = fastqToFasta.start(); 					conversion.waitFor();				}			}		}	}	/**	 * This function takes a perlscript present in the resources folder of this program and runs each file through it while providing each file with new names according to	 * a file that must be found in the root directory called names.txt. names.txt is formatted as "WorkingID , SampleID" whitespace is not significant and will be stripped.	 * @param fastaFiles	 * @throws URISyntaxException	 * @throws IOException	 * @throws InterruptedException	 */	public void appearDemultiplexed(String fastaFiles) throws URISyntaxException, IOException, InterruptedException{		CodeSource codeSource = qiimePipeline.class.getProtectionDomain().getCodeSource(); // modified slightly from http://stackoverflow.com/questions/320542/how-to-get-the-path-of-a-running-jar-file		File jarFile = new File(codeSource.getLocation().toURI().getPath());		String jarDir = jarFile.getParentFile().getPath();		String demultiplexingScript = jarDir + "/resources/prepare_qiime_input_fasta.pl";		File fastaFile = new File(sourceFolder.getParentFile().getAbsolutePath() + "/" + fastaFiles);		@SuppressWarnings("resource")		BufferedReader nameParser = new BufferedReader(new FileReader(new File(sourceFolder.getParentFile().getAbsolutePath() + "/names.txt")));		String line;		HashMap<String, String> nameMap = new HashMap<String, String>();		line = nameParser.readLine();		while ((line != null) && !line.equals("")){			String[] parsingArray = line.split(",");//this creates a parser that splits on "," and trims out whitespace, and finally puts the working ID and unique Sample ID in a key value combo in a hashmap			String fileName = parsingArray[0].trim();			String sampleID = parsingArray[1].trim();			nameMap.put(fileName, sampleID);			line = nameParser.readLine();		}					for (File fasta: fastaFile.listFiles()){			int endIndex = (fasta.getName().length() -6); //This is so that you can get the part before the file extension			String fileName = fasta.getName().substring(0,endIndex); 			String sampleID = nameMap.get(fileName);			ProcessBuilder demultiplex = new ProcessBuilder().directory(new File(sourceFolder.getParent() + "/demultiplexed")).inheritIO().command("bash", "-c", "perl" 			+ " " + demultiplexingScript + " " + sampleID + " " + fasta.getAbsolutePath() + " > " + sampleID + ".fa"); //run demultiplexing script			Process demultiplexer = demultiplex.start();			demultiplexer.waitFor();		}	}	/**	 * Concatenates all of the input files into one file for input into QIIME.	 * This takes each file and concatenates on the previous file, leaving a final output in the root directory of the working directory.	 * @param faFiles	 * @throws InterruptedException	 * @throws IOException	 */	public void concatenateForQIIME(String faFiles) throws InterruptedException, IOException{		File input = new File(sourceFolder.getParent() + "/" + faFiles);		for (File fa: input.listFiles()){			ProcessBuilder catter = new ProcessBuilder().directory(new File(sourceFolder.getParent())).inheritIO().command("bash", "-c", "cat " + sourceFolder.getParent() + 					"/demultiplexed/" +  fa.getName() + " >> concatenatedFile");			Process cat = catter.start();			cat.waitFor();		}	}	/**	 * This operates the entire pathway, does not take any arguments as input and throws all the exceptions	 * @param args	 * @throws IOException	 * @throws InterruptedException	 * @throws URISyntaxException	 */	public static void main(String[] args) throws IOException, InterruptedException, URISyntaxException {		File myDirectory = chooseFile("Working Directory"); 		String myFile = myDirectory.getAbsolutePath();		qiimePipeline myPipeline = new qiimePipeline(myFile);		myPipeline.setFLASHlocation(chooseFile("Path to FLASH").getAbsolutePath());		myPipeline.indexR1TrimGalore();		myPipeline.matchR2TrimGalore();		myPipeline.createWorkingFolder("trimOut");		myPipeline.trim();		myPipeline.createWorkingFolder("FLASHout");		File trimOut = new File (myPipeline.sourceFolder.getParentFile().getPath() + "/trimOut");		myPipeline.setFLASHfiles(trimOut);		myPipeline.indexR1FLASH();		myPipeline.matchR2FLASH();		myPipeline.FLASH();		myPipeline.createWorkingFolder("convertToFasta");		myPipeline.fastqToFasta("FLASHout");		myPipeline.createWorkingFolder("demultiplexed");		myPipeline.appearDemultiplexed("convertToFasta");		myPipeline.concatenateForQIIME("demultiplexed");		// TODO Auto-generated method stub	}}